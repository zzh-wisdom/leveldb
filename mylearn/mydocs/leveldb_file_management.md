# LevelDB文件管理

> #LevelDB之文件格式: <https://www.dazhuanlan.com/2020/02/11/5e4207bd37e91/>

每个数据库由存储在目录中的一组文件表示。有几种不同类型的文件，如下所述。

## 1. DB文件分类

```cpp
enum FileType {
  kLogFile,
  kDBLockFile,
  kTableFile,
  kDescriptorFile,
  kCurrentFile,
  kTempFile,
  kInfoLogFile  // Either the current one, or an old one
};
```

一个数据库包含7种文件:

1. kLogFile: WAL日志文件，文件名为[0-9]+.log，读方式：**NewSequentialFile**
2. kDBLockFile: db锁文件，文明名为LOCK，通过LOCK文件加文件锁（flock）来实现只有一个实例能操作db，使用了操作系统对文件提供的锁机制。同时只有一个进程可以对文件上锁。
3. kTableFile: sstable文件，文件名为[0-9]+.sst
4. kDescriptorFile: db元数据文件，存储系统中version信息，文件名为MANIFEST-[0-9]+，每当db发生compaction时，对应的versionedit会记录到descriptor文件中
5. kCurrentFile: 记录当前使用的descriptor文件名，文件名为CURRENT，读方式：**NewSequentialFile**
6. kTempFile: 临时文件，db在修复过程中会产生临时文件，文件名为[0-9]+.dbtmp
7. kInfoLogFile: db运行过程中的日志文件，文件名为LOG。

### 1.1. Log files

**文件名格式**：<dbname>/[0-9]+.log

日志文件（* .log）存储一系列最近的更新。每个更新都附加到当前的日志文件。日志文件达到预定大小时（默认情况下约为4MB），它会转换为有序的table（请参见下文）并创建一个新的日志文件以供将来更新。

当前的log文件在内存中的存在形式就是`memtable`，每次read操作都会访问memtable，以保证read读取到的是最新的数据。



日志恢复期间，若日志文件打开失败，数据库可以正确使用，错误以日志的形式打印到系统日志文件中。

### SSTable文件(Sorted tables)

**文件名格式：**

- <dbname>/[0-9]+.sst
- <dbname>/[0-9]+.ldb

SSTable存储按键排序的一系列条目。 每个条目要么是键的值，要么是键的删除标记。（删除标记可以覆盖更老sstable文件中过期的value）。

SSTable的集合被组织为一系列级别。 从日志文件生成的SSTable放置在level 0中。 当level 0的文件数量超过某个阈值（当前为4个）时，所有level 0文件将与所有重叠的level 1文件合并在一起，以产生一系列新的level 1文件。每个level 1文件大小为2MB。

**level 0文件之间可能包含重复的Key。 对于Level>0，同层sstable文件的key不会重叠**。 ==考虑L>0，当级别L中的所有文件总大小超过 10^L MB（即，L=1为10MB，L=2为100MB，...）时， 级别L和级别 L+1 中的所有重叠文件都合并为级别 L+1 的一组新文件。 Merge操作的作用是将新的更新从低一级level迁移到更高级，且只使用批量读写（最小化seek操作，提高效率）。==

### Manifest(db元数据文件)

**文件名格式**：<dbname>/MANIFEST-[0-9]+

MANIFEST文件列出了组成每个级别的SSTable集、相应的键范围和其他重要的元数据。 每当重新打开数据库时，都会创建一个新的MANIFEST文件（文件名中嵌入一个新数字）。 MANIFEST文件的格式就像一个日志，并且对服务状态所做的更改（添加或删除文件时）将添加到此日志中。

### Current

**文件名格式**：<dbname>/CURRENT

是一个简单的文本文件，记录当前正在使用的Manifest文件。

因为在LevleDb的运行过程中，随着Compaction的进行，新的SSTable文件被产生，老的文件被废弃。并生成新的Manifest文件来记载sstable的变动，而CURRENT则用来记录我们关心的Manifest文件。

### Info logs（系统日志文件）

文件名：<dbname>/LOG 和 <dbname>/LOG.old

系统的运行日志，记录系统的运行信息或者错误日志。

Others 其他文件

如临时文件（*.dbtmp）和LOCK文件。

## Level 0

当日志文件超过一定大小（默认为4MB）时：

首先，创建一个全新的内存表和日志文件，并在此处保存将来的更新。

然后，在后台：

1. 将前一个内存表的内容写入一个sstable中。
2. 丢弃该内存表。
3. 删除旧的日志文件和旧的内存表。
4. 将新的sstable添加到level 0。

## Compaction

当级别L的大小超过其限制时，我们在后台线程中将其压缩。 Compaction从级别L中选择**一个文件**，并从下一级别 L+1 中选择所有重叠的文件。 请注意，如果级别L文件仅与级别 L+1 文件的一部分重叠，则级别 L+1 的整个文件将用作压缩的输入，并且在压缩后将被丢弃。

特别的，由于级别0是特殊的（文件之间可能会相互重叠），因此我们特别对待从级别0到级别1的压缩：级别0压缩可能会选择多个级别0的文件，以防其中某些文件相互重叠。

Compaction合并被选取文件的内容以生成一系列级别 L+1 的文件。 生成新文件的规则是：

- 当前输出文件达到目标文件大小（2MB）之后，我们切换到新生成的level L+1 文件。
- 当前输出文件的Key范围增长到足以重叠十个以上级别 L+2 的文件时，我们也将切换到新的输出文件。

最后一条规则确保以后对级别 L+1 文件的压缩不会从级别 L+2 中获取太多数据。

旧文件将被丢弃，新文件将被添加到服务状态。

特定级别的压缩在Key空间中旋转。 更详细地讲，对于每个级别L，我们都记得级别L的**最后一次压缩的结束键**。对于级别L的下一次压缩将选择在该键之后开始的第一个文件（如果没有这样的文件，则环绕到Key空间的开头）。

Compaction将删除覆盖的值。 如果更高级别的文件没有包含与当前文件重叠的键，则还会丢弃删除标记。

## Timing 时间

0级压缩将从0级读取最多四个1MB文件和所有1级文件（最坏的情况下，10MB）。也就是说，我们将读取14MB并写入14MB数据。

除了特殊的0级压缩外，我们将从L级中选择一个2MB的文件。在最坏的情况下，它将与 L+1 级中的大约12个文件重叠（其中10个是因为level L+1 的大小是其十倍，另外2个是边界导致的，因为级别L的文件范围通常不会与级别 L+1 的文件范围对齐）。 因此，压缩将读取26MB并写入26MB。 假设磁盘IO速率为100MB/s（现代驱动器的扩展范围），**则最差的压缩成本约为0.5秒**。

如果我们将后台写入速度控制在很小的水平，例如100MB/s的10％，则压缩可能需要5秒钟。 如果用户以10MB/s的速度写入，我们可能会建立许多0级文件（大约50个来容纳 5*10MB）。 由于在每次读取时需要读取多个L0文件，这可能会大大增加读取成本。

解决方法：

- 方法一：为减少此问题，当0级文件的数量很大时，我们可能希望增加日志切换的阈值。 尽管不利之处在于此阈值越大，保存对应的内存表所需的**内存就越多**。
- 当级别0文件的数量增加时，我们可能希望人为地降低写入率。
- 我们致力于降低大Key范围合并的成本。 也许大多数0级文件的块被放置在缓存中未压缩（可以把level 0文件都无压缩的存放在cache中），我们只需要担心合并迭代器的 O(N) 复杂性。

## Number of files 文件数量

不必总是制作2MB的文件，我们可以为更大的级别制作更大的文件，以减少总文件数，尽管以更多的突发压缩为代价。 另外，我们可以将文件集分成多个目录。

2011年2月4日对ext3文件系统进行的一项实验显示了在文件数量不同的目录中打开100K文件的耗时如下：

| Files in directory | Microseconds to open a file |
| -----------------: | :-------------------------- |
|               1000 | 9                           |
|              10000 | 10                          |
|             100000 | 16                          |

所以当目录中的文件数较少时，打开文件的效率更高。

## Recovery 恢复

- 读CURRENT文件以查找最新提交的MANIFEST文件名
- 读最新的MANIFEST文件
- 清理陈旧的文件
- 我们可以在这里打开所有的sstables，但是最好还是惰性(lazy)打开...
- 将日志块转换为新的0级sstable
- 开始将新的写入定向到新的日志文件（从恢复的序号开始）

## Garbage collection of files

在每次**压缩**结束和**恢复**结束时都会调用`RemoveObsoleteFiles()`。 它查找数据库中所有文件的名称。 它将删除不是当前日志文件的所有日志文件，删除所有未从某个级别引用且不是活动Compaction输出的table文件。
